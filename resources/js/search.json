[[{"l":"Welcome","p":["Joos is fully-featured open-source library built for the FTC robotics competition. From simple button presses to advanced motion planning, Joos aims to have something for everything.","Some features include:","Powerful FTC Dashboard integration","Flexible command system","Complex trajectories, including waits and turns","Support for Mecanum, Tank, Swerve, and Differential Swerve out-of-the-box","An advanced multi-platform GUI that supports draggable waypoints","Useful wrappers for Motors, Servos, Gamepads, and more","To get started, head over to the installation page."]}],[{"l":"Installation"},{"l":"Manual","p":["(this one)","/.github","/.gitignore","/doc","/FtcRobotController","/gradle/wrapper","/lib","/libs","/src","/TeamCode","And add the annotation processor to the dependencies block:","build.common.gradle","build.dependencies.gradle","build.gradle","gradle.properties","gradlew","gradlew.bat","If you don't want to utilize all of Joos' capabilities, but just want its core navigation features, you can replace 'command' with 'navigation' in the import statement.","If you haven't already, download the FTC SDK from its GitHub repository.","If you want to use Joos' FTC Dashboard integration, then you'll need to install Joos' custom annotation processor. Open the TeamCode build.gradle file:","If you're using Kotlin instead of Java, you'll have to use KSP to install the annotation processor.","In the build.dependencies.gradle file, add the following lines to the repositories block and the Joos import in the dependencies block:","Note that if you are just using the navigation module, this step isn't necessary.","README.md","settings.gradle","Since Joos uses newer Java features, it isn't compatible with the Android SDK versions 23 and lower. In the build.common.gradle file, change minSdkVersion from 23 to 24:","That's it! Get started, or take a look at the [reference]."]},{"l":"Quickstart","p":["You can download the quickstart from this GitHub repository by cloning it into a fresh Android Studio project:","Downloading the Quickstart","After that, you should be good to go! The quickstart comes with additional tuning OpModes, and for further instructions on those, head to the [quickstart reference]."]}],[{"l":"Intro to Commands","p":["One key aspect of efficient robots is being able to coordinate multiple actions simultaneously. Whether it be spinning and scoring ducks at the same time, or picking up and shooting rings at the same time, there are parts of a game that lend themselves to multitasking. Accomplishing this behavior, however, can sometimes prove to be difficult.","The most common method of doing multiple things at once is through state machines, where each part of the robot can be updated at different times while they all keep track of their states:","When dealing with many robot parts, however, this code can increase in size and complexity very quickly. You can remedy this problem slightly by putting the logic of each part in its own class and calling some update method, but each individual class can still be quite complicated.","Joos's command system aims to make asynchronous code more powerful and easy to write, making your code more effective."]},{"l":"The Command","p":["A Command is just a simple state machine with 2 states: running and not running. The state is returned by a command's isFinished method. If isFinished returns false, execute is called and the command keeps on running. Otherwise, it stops.","Besides these two basic methods, commands have 2 more: init and end. init is called right when the command is scheduled for execution, and end, naturally, is called when the command ends."]},{"l":"The Component","p":["Robot mechanisms have to do other things besides following commands, like updating a pose estimate or a PID controller. These things do not fit nicely into a Command, which is where the Component comes in. The Component interface has only one method: update, but is still very useful for separating code for different parts of your robot.","In addition, components are able to be required by a command. This feature becomes useful when cancelling commands, or scheduling conflicting commands. For example, when 2 commands that require the same component are scheduled, one of them is automatically cancelled."]},{"l":"The Robot","p":["The Robot class serves only to organize your command-based code. In it you can construct and register all your components as well as set up basic commands for every OpMode. It provides init and start methods that are called before init and start in RobotOpMode s, which just automatically handle the creation and updating of robots."]},{"l":"Putting It All Together","p":["Creating a component is as easy as implementing the Component interface:","You may have noticed that this example uses AbstractComponent instead of Component. The only difference is that AbstractComponent makes it easier to deal with subcomponents, like motors.","All of your components, once written, can be put into a Robot like so:","Once you have a Robot complete with components, rather than use a normal OpMode or LinearOpMode, you can use a CommandOpMode for all your TeleOp and Autonomous needs. It provides you with direct access to the CommandScheduler, a MultipleGamepad, and automatic handling of Robot s. To create one, simply extend it as you would a normal OpMode, and override the preInit method. Any telemetry sent in preInit will be updated immediately, and any commands scheduled or components registered will update once the OpMode starts. To register a Robot, call registerRobot in preInit.","That's the basics! For more detailed explanations of every part of Joos' command system, keep reading."]}],[{"l":"Component","p":["A Component has one main method, update, which is repeatedly called by the CommandScheduler. In addition, Component s have an optional getDefaultCommand method which returns a command that is scheduled whenever they are not in use. Component s can only be used by one Command at a time to avoid conflict between commands.","Instead of creating a separate class, components can also be inlined with Component.of:"]},{"l":"AbstractComponent","p":["AbstractComponent is an abstract version of Component with several utility methods that make your life easier.","Currently, the only added functionality AbstractComponent provides is support for subcomponents, like Motor s and Servo s, that need their own update methods called, but aren't a separate component of the robot. To add a subcomponent, use subcomponents.add(), and if you override update(), make sure to insert a call to super.update() as well."]}],[{"l":"Command"},{"l":"Creating a Command","p":["A command can be created in one of two ways: a separate class and inlining."]},{"l":"A Command as a Class","p":["Making a command a separate class is very useful when dealing with very complicated commands and commands that extend other commands."]}],[{"l":"BasicCommand","p":["The BasicCommand was designed with inlining in mind and, as such, is easily decorated. To create a BasicCommand, pass in a runnable to its primary constructor, or alternatively, use Command.of."]}],[{"l":"InstantCommand","p":["An InstantCommand is similar to a BasicCommand in that it simply runs an action once, but unlike a BasicCommand, and InstantCommand runs its action in init rather than execute, making it effectively instant. InstantCommand s are useful only for the most basic actions."]}],[{"l":"FunctionalCommand","p":["FunctionalCommand s, like BasicCommand s, are meant for inlining, but are more customizable. A FunctionalCommand takes all the Command methods, along with isInterruptable and component requirements, as constructor parameters, allowing for the dynamic creation of entire commands.","In addition, all of the FunctionalCommand's properties are mutable, and so can be configured after creation:","FunctionalCommand s can also be created through decoration. See this in action here."]}],[{"l":"WaitCommand","p":["A WaitCommand does simply that: waits a specified duration before ending. This command is useful for adding delay between actions. WaitCommand s can also be created through decoration."]}],[{"l":"TimeCommand","p":["A TimeCommand is an easy way to create time-based commands without having to create a separate class and use a timer. Its only argument is a function that takes in two doubles, the total amount of time the command has been running and the time elapsed since the last call to the function (both in seconds), and returns whether the command is finished. This type of command is useful for things that require the current time, like motion profiles."]}],[{"l":"SelectCommand","p":["A SelectCommand runs a different command every time it is scheduled, taking in a function that provides a command which it then runs. SelectCommand s are useful when you need to create a command before it is scheduled, but still want it to have dynamic behavior. Command.select is also available to create SelectCommand s.","One use case of SelectCommand is button mapping, where depending on some other current state, a different action is performed:"]}],[{"l":"ListenerCommand","p":["A ListenerCommand runs different actions whenever a command initializes, executes, or ends. It takes it the command to listen for and the actions to run on init, execute, and end."]}],[{"l":"RepeatCommand","p":["A RepeatCommand runs a command multiple times. Once the command finishes, it is initialized and run again as many times as specified. It takes in the command to repeat and the number of times to run it. If the number is less than zero, it will repeat forever."]}],[{"l":"Command Groups","p":["Command groups join multiple commands into one single command. Depending on how they join commands, command groups can also require their commands to have different requirements, like, for example, when they are run in parallel and cannot use the same components at the same time.","All the current types of command groups are outlined below:","Commmand Group","Description","SequentialCommand","Runs commands in sequence, one after the other.","ParallelCommand","Runs commands in parallel until they all finish.","RaceCommand","Runs commands in parallel until only one of them finishes."]}],[{"l":"Decorating Commands","p":["Although the different commands Joos provides are very useful, they can sometimes be cumbersome to put together to form new commands. Take this example:","It adds a delay of 4 seconds after myCommand finishes. This is not difficult to write, but the syntax can be condensed greatly:","Here are all the shortcuts you can use to add functionality to your commands:","[]"]}],[{"l":"The GUI","p":["Path planning can be difficult when using coordinates without any sort of visualization. The Joos GUI aims to make path planning as smooth as possible, so all you have to worry about is where you want the robot to go, not how to make it get there.","Opening the GUI","To get started with the GUI, you can either import it into an Android Studio / IntelliJ IDEA project or download it as a standalone application."]},{"l":"Downloading the GUI","p":["The GUI downloads are available here. There are platform-specific distributions, so make sure to download the right one for your operating system. After downloading and extracting the zip file, run the launcher executable located in the /bin folder.","/joos-gui-(version)-(platform)","/bin","...","launcher(this one)","/conf","/legal","/lib","release"]},{"l":"Importing the GUI","p":["To import the GUI, create an empty java gradle module and add the following to your build.gradle file:"]},{"l":"Usage","p":["The GUI is split into two parts: the editor and the field view. The editor is where you can modify the trajectory as well as the robot size and constraints, and the field view displays the trajectory and allows the waypoints to be dragged (yes, DRAGGED) to fine tune the trajectory.","To add a segment, right click on the waypoint you want to add a segment to, and select the type of waypoint. In the field view the waypoint will appear on top of the waypoint before it, and can be dragged. To export the trajectory, right click on the waypoint list (but not on the waypoints) and select your export method. To start trajectory playback, click on the field view or press space. The trajectory progress bar is also draggable to scrub to specific parts of your trajectory.","Here's a simple demo of the GUI's capabilities:"]}]]