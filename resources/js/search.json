[[{"l":"Welcome","p":["Joos is fully-featured open-source library built for the FTC robotics competition. From simple button presses to advanced motion planning, Joos aims to have something for everything.","Some features include:","Powerful FTC Dashboard integration","Flexible command system","Complex trajectories, including waits and turns","Support for Mecanum, Tank, Swerve, and Differential Swerve out-of-the-box","An advanced multi-platform GUI that supports draggable waypoints","Useful wrappers for Motors, Servos, Gamepads, and more","To get started, head over to the installation page."]}],[{"l":"Installation"},{"l":"Manual","p":["(this one)","/.github","/.gitignore","/doc","/FtcRobotController","/gradle/wrapper","/lib","/libs","/src","/TeamCode","build.common.gradle","build.dependencies.gradle","build.gradle","gradle.properties","gradlew","gradlew.bat","If you don't want to utilize all of Joos' capabilities, but just want its core navigation features, you can replace 'command' with 'navigation' in the import statement and remove the annotation processor.","If you haven't already, download the FTC SDK from its GitHub repository.","If you're using Kotlin instead of Java, you'll have to use KSP to install the annotation processor.","In the build.gradle file in the TeamCode folder, add the following repositories block and the Joos imports in the dependencies block:","Open the TeamCode build.gradle file:","README.md","settings.gradle","That's it! Get started, or keep reading."]},{"l":"Quickstart","p":["You can download the quickstart from this GitHub repository by cloning it into a fresh Android Studio project:","Downloading the Quickstart","After that, you should be good to go! The quickstart comes with additional tuning OpModes, and for further instructions on those, head to the quickstart.","Installation"]}],[{"l":"Quickstart Overview","p":["The tuning process to derive the constants to control a robot can be divided into 4 basic parts:","Basic hardware configuration.","Localization tuning.","Feedforward tuning.","Feedback tuning.","As of right now, the quickstart only has out-of-the-box support for mecanum drives and dead wheel localization for three wheels. Most of the actual tuning logic has been abstracted enough to be easily adaptable to any drive and localization setup, however, so most of these steps will apply regardless."]},{"l":"Hardware Configuration","p":["All of the hardware ID's in the quickstart are stored in the SampleRobot class. Make sure they are all set to match your robot configuration. Note that the IMU is only required for AngularRampLogger and your localization if it needs an external heading sensor.","Once you have your hardware correctly configured, you have to make sure all motors and encoders are set to the correct directions. To aid in this, you have three options: MotorDirectionDebugger, LocalizationTest, and EncoderDirectionDebugger. For your drive motors, you can either use MotorDirectionDebugger and run each motor individually to see which need to be reversed (they should all drive forwards), or use LocalizationTest to drive forward and diagnose all the motors at once. For LocalizationTest it may be beneficial to have the robot on its side or another angle where it is easier to see the wheels.","If you have encoders separate from your drive motors, you can use EncoderDirectionDebugger and spin each encoder by hand forwards to see which are reversed. Note that for perpendicular encoders that point left or right, forwards is to the left of the robot."]},{"l":"Localization Tuning","p":["The first step to tuning your localization is ForwardPushTest(and LateralPushTest if you're using mecanum drive). Push the robot forwards a specific distance, and measure it. The telemetry will print out the estimated distance (in ticks, initially). Multiply your distancePerTick(in SampleMecanumDrive) by the actual distance divided by the estimated distance. To get a more accurate result, you can take the average of multiple repetitions of this process.","For mecanum drives, since they move slower when strafing, a separate number has to account for distance travelled when strafing. Repeat the same pushing process as for ForwardTest, except this time to the left. Multiply lateralMultiplier(in SampleMecanumDrive) by the actual distance divided by the estimated distance. This number should be less than one.","Once you've completed the push tests, you can determine the position of your encoders through either AngularRampLogger or EncoderPositionTuner, the former being automatic and the latter manual. Both accomplish the same thing. For AngularRampLogger, the robot will spin counter-clockwise for 5 seconds (by default) to determine the position of your encoders. For EncoderPositionTuner, you will have to spin the robot exactly 10 times counter-clockwise (by default) with the right joystick and then press A/X (Xbox/PS) to get your positions.","That's it! You can run LocalizationTest to test your localization accuracy. If you find it lacking, you can either repeat the previous tuning steps or fine-tune your constants manually."]},{"l":"Feedforward Tuning","p":["Run ManualFeedforwardTuner. The robot will eventually move back and forth roughly 4 feet, once all values are tuned. It's recommended for this step and for the feedback tuning to use FTC Dashboard. It comes pre-installed with the quickstart, so there's no setup required.","Begin by setting all your feedforward values (found in feedforward in SampleMecanumDrive) to 0. Then follow these steps:","Increase kStatic until the robot just barely starts to move.","Increase kV until the robot reaches the maximum target speed. It's easier to see this with FTC Dashboard's graph view.","Increase kA to make the acceleration and decceleration portions of the graph more accurate.","If at any point the robot drifts away from where you want it, you can press Y/△ (Xbox/PS) to enter drive control, and then B/〇 (Xbox/PS) to continue tuning once it's reset. Note also that you should start at really small values when tuning (like 0.00001) and then increase until it begins to have an effect. It's better to have your robot be unresponsive at first then speed off uncontrollably."]},{"l":"Feedback tuning","p":["Run ManualFeedbackTuner. The robot will move forward and back while turning. The variables to modify here are all those that end in \"coeffs\" in SampleMecanumDrive. These are the PID coefficients for a basic trajectory-following controller. To tune them, first set them all to 0, then:","Increase kP to reduce error","If you feel it is necessary, increase kD slightly to dampen oscillations.","Do not use kI. It is not beneficial in a trajectory-following context and may reduce performance.","That's it! You're all tuned."]}],[{"l":"Command"},{"l":"Creating a Command","p":["A command can be created in one of two ways: a separate class and inlining."]},{"l":"A Command as a Class","p":["Making a command a separate class is very useful when dealing with very complicated commands and commands that extend other commands.","Here you have fine control over everything that your command does. If you're looking for something simpler, try inlining your command."]},{"l":"Inlining Commands","p":["What if you wanted a command that ran two commands in parallel and after both finished waited 5 seconds before finally running another command? With inlining that would look something like this:","This page is under construction."]}],[{"l":"Intro to Commands","p":["One key aspect of efficient robots is being able to coordinate multiple actions simultaneously. Whether it be spinning and scoring ducks at the same time, or picking up and shooting rings at the same time, there are parts of a game that lend themselves to multitasking. Accomplishing this behavior, however, can sometimes prove to be difficult.","The most common method of doing multiple things at once is through state machines, where each part of the robot can be updated at different times while they all keep track of their states:","When dealing with many robot parts, however, this code can increase in size and complexity very quickly. You can remedy this problem slightly by putting the logic of each part in its own class and calling some update method, but each individual class can still be quite complicated.","Joos's command system aims to make asynchronous code more powerful and easy to write, making your code more effective."]},{"l":"The Command","p":["A Command is just a simple state machine with 2 states: running and not running. The state is returned by a command's isFinished method. If isFinished returns false, execute is called and the command keeps on running. Otherwise, it stops.","Besides these two basic methods, commands have 2 more: init and end. init is called right when the command is scheduled for execution, and end, naturally, is called when the command ends."]},{"l":"The Component","p":["Robot mechanisms have to do other things besides following commands, like updating a pose estimate or a PID controller. These things do not fit nicely into a Command, which is where the Component comes in. The Component interface has only one method: update, but is still very useful for separating code for different parts of your robot.","In addition, components are able to be required by a command. This feature becomes useful when cancelling commands, or scheduling conflicting commands. For example, when 2 commands that require the same component are scheduled, one of them is automatically cancelled."]},{"l":"The Robot","p":["The Robot class serves only to organize your command-based code. In it you can construct and register all your components as well as set up basic commands for every OpMode. It provides init and start methods that are called before init and start in RobotOpMode s, which just automatically handle the creation and updating of robots."]},{"l":"Putting It All Together","p":["Creating a component is as easy as implementing the Component interface:","You may have noticed that this example uses AbstractComponent instead of Component. The only difference is that AbstractComponent makes it easier to deal with subcomponents, like motors.","All of your components, once written, can be put into a Robot like so:","Once you have a Robot complete with components, rather than use a normal OpMode or LinearOpMode, you can use a CommandOpMode for all your TeleOp and Autonomous needs. It provides you with direct access to the CommandScheduler, a MultipleGamepad, and automatic handling of Robot s. To create one, simply extend it as you would a normal OpMode, and override the preInit method. Any telemetry sent in preInit will be updated immediately, and any commands scheduled or components registered will update once the OpMode starts. To register a Robot, just create a non-final field annotated with @Register if using Java, or the robot delegate if using Kotlin.","That's the basics! For more detailed explanations of every part of Joos' command system, keep reading."]}],[{"l":"Component","p":["A Component has one main method, update, which is repeatedly called by the CommandScheduler. In addition, Component s have an optional getDefaultCommand method which returns a command that is scheduled whenever they are not in use. Component s can only be used by one Command at a time to avoid conflict between commands.","Instead of creating a separate class, components can also be inlined with Component.of:"]},{"l":"AbstractComponent","p":["AbstractComponent is an abstract version of Component with several utility methods that make your life easier.","Currently, the only added functionality AbstractComponent provides is support for subcomponents, like Motor s and Servo s, that need their own update methods called, but aren't a separate component of the robot. It also gives you telem to access SuperTelemetry. To add a subcomponent, use subcomponents.add(), and if you override update(), make sure to insert a call to super.update() as well."]}],[{"l":"BasicCommand","p":["The BasicCommand was designed with inlining in mind and, as such, is easily decorated. To create a BasicCommand, pass in a runnable to its primary constructor, or alternatively, use Command.of."]}],[{"l":"InstantCommand","p":["An InstantCommand is similar to a BasicCommand in that it simply runs an action once, but unlike a BasicCommand, and InstantCommand runs its action in init rather than execute, making it effectively instant. InstantCommand s are useful only for the most basic actions."]}],[{"l":"FunctionalCommand","p":["FunctionalCommand s, like BasicCommand s, are meant for inlining, but are more customizable. A FunctionalCommand takes all the Command methods, along with isInterruptable and component requirements, as constructor parameters, allowing for the dynamic creation of entire commands.","In addition, all of the FunctionalCommand's properties are mutable, and so can be configured after creation:"]}],[{"l":"WaitCommand","p":["A WaitCommand does simply that: waits a specified duration before ending. This command is useful for adding delay between actions."]}],[{"l":"TimeCommand","p":["A TimeCommand is an easy way to create time-based commands without having to create a separate class and use a timer. Its only argument is a function that takes in two doubles, the total amount of time the command has been running and the time elapsed since the last call to the function (both in seconds), and returns whether the command is finished. This type of command is useful for things that require the current time, like motion profiles."]}],[{"l":"SelectCommand","p":["A SelectCommand runs a different command every time it is scheduled, taking in a function that provides a command which it then runs. SelectCommand s are useful when you need to create a command before it is scheduled, but still want it to have dynamic behavior. Command.select is also available to create SelectCommand s.","One use case of SelectCommand is button mapping, where depending on some other current state, a different action is performed:"]}],[{"l":"ListenerCommand","p":["A ListenerCommand runs different actions whenever a command initializes, executes, or ends. It takes it the command to listen for and the actions to run on init, execute, and end."]}],[{"l":"RepeatCommand","p":["A RepeatCommand runs a command multiple times. Once the command finishes, it is initialized and run again as many times as specified. It takes in the command to repeat and the number of times to run it. If the number is less than zero, it will repeat forever."]}],[{"l":"Command Groups","p":["Command groups join multiple commands into one single command. Depending on how they join commands, command groups can also require their commands to have different requirements, like, for example, when they are run in parallel and cannot use the same components at the same time.","All the current types of command groups are outlined below:","Commmand Group","Description","SequentialCommand","Runs commands in sequence, one after the other.","ParallelCommand","Runs commands in parallel until they all finish.","RaceCommand","Runs commands in parallel until only one of them finishes."]}],[{"l":"Decorating Commands","p":["Although the different commands Joos provides are very useful, they can sometimes be cumbersome to put together to form new commands. Take this example:","It adds a delay of 4 seconds after myCommand finishes. This is not difficult to write, but the syntax can be condensed greatly:","Here are some of the shortcuts you can use to add functionality to your commands:","For the rest of the ways you can decorate commands, see the Kotlin docs or Java docs."]},{"l":"Delays"},{"l":"Command Groups"}],[{"l":"Getting Started","p":["It's recommended to glance through the Java or Kotlin docs to get a feel for what kind of stuff is provided by this module, but here's a quick rundown:","Basic geometry classes ( Pose2d, Vector2d, and Angle)","Kinematics for mecanum, tank, swerve, and differential swerve drives, as well as general robot kinematics","A PID controller and DC motor feedforward","Odometry localization for all the drives mentioned above and dead wheels (2 or 3)","Path, motion profile, and trajectory generation","State-of-the-art trajectory and path following algorithms","JSON-serializable trajectories","Kinematics, localization, and the following algorithms all require robot-specific parameters which can only be found through tuning. For that, see the quickstart. It provides plenty of tuning OpModes to get you up and running."]}],[{"l":"Motivation","p":["To get a robot to move how you want it to, you need to figure out three things:","Where the robot is.","What exact movements the robot needs to make to reach its target.","How to get the robot to follow those movements and respond to errors.","In FTC, #1 is typically accomplished using a process called dead reckoning with encoders on either drive wheels, or sprung unpowered wheels known as \"dead wheels\" or \"odometry wheels\". To accomplish this, both the exact positions of all encoders and the conversion from encoder ticks to distance must be known.","For #2, paths are pre-defined, typically using splines. Joos uses parametric representations of quintic bezier curves for this purpose. From there, usually a motion profile is constructed to ensure that any commanded velocities respect the robot's constraints.","Lastly, for #3, there are a variety of different controllers designed to ensure the robot stays on the desired trajectory. Techniques can range from as simple as a basic PID controller to a more complicated guiding vector field. Joos includes a collection of multiple controllers for you to experiment with.","Each of these steps requires some robot-specific knowledge, so the quickstart is designed to help you figure that out, well, quickly."]}],[{"i":"joos-ftc-dashboard","l":"Joos + FTC Dashboard (=\uD83D\uDD25)","p":["The biggest change from just FTC Dashboard to Joos is changing all @Config to @JoosConfig. What's the difference?","First-class Kotlin support. No more @JvmStatic and support for top-level properties.","Works on individual variables, so not all static variables are editable.","Works on immutable variables.","Supports immutable Kotlin data classes via @Immutable.","Supports custom config providers with @MutableConfigProvider and @ImmutableConfigProvider.","Here's an example of some of the differences:"]},{"l":"SuperTelemetry","p":["Ever had issues trying to use FTC Dashboard's MultipleTelemetry and the field overlay at the same time? SuperTelemetry solves all of them! It has all the functionality of MultipleTelemetry while giving you access to its field overlay and not requiring any setup! To use it, just replace telemetry with SuperTelemetry in your OpModes, or just telem if using CommandOpModes."]}],[{"l":"JavaFX","p":["This version of the GUI is deprecated and will no longer be supported.","Path planning can be difficult when using coordinates without any sort of visualization. The Joos GUI aims to make path planning as smooth as possible, so all you have to worry about is where you want the robot to go, not how to make it get there. This is the currently stable version, but will be deprecated in the future. It will receive no further updates. To see the new GUI, head here.","Opening the GUI","To get started with the GUI, you can either import it into an Android Studio / IntelliJ IDEA project or download it as a standalone application."]},{"l":"Downloading the GUI","p":["The GUI downloads are available here. There are platform-specific distributions, so make sure to download the right one for your operating system. After downloading and extracting the zip file, run the launcher executable located in the /bin folder.","/joos-gui-(version)-(platform)","/bin","...","launcher(this one)","/conf","/legal","/lib","release"]},{"l":"Importing the GUI","p":["To import the GUI, create an empty java gradle module and add the following to your build.gradle file:"]},{"l":"Usage","p":["The GUI is split into two parts: the editor and the field view. The editor is where you can modify the trajectory as well as the robot size and constraints, and the field view displays the trajectory and allows the waypoints to be dragged (yes, DRAGGED) to fine tune the trajectory.","To add a segment, right click on the waypoint you want to add a segment to, and select the type of waypoint. In the field view the waypoint will appear on top of the waypoint before it, and can be dragged. To export the trajectory, right click on the waypoint list (but not on the waypoints) and select your export method. To start trajectory playback, click on the field view or press space. The trajectory progress bar is also draggable to scrub to specific parts of your trajectory.","Here's a simple demo of the GUI's capabilities:"]}],[{"l":"Web","p":["The Joos GUI is currently moving to the web! It currently supports nearly all previous GUI features, but lacks any styling / theming. You can try it out here."]},{"l":"Current Features","p":["Draggable waypoints and tangents","Editable turn and wait segments","Trajectory visualization with scrub bar and custom constraints","Custom field backgrounds"]},{"l":"Planned features","p":["Better styling and custom themes","Webserver integration to be able to edit trajectories directly on the Robot Controller","If you have any more suggestions or questions on how any of this works, please let me know!"]},{"l":"Exporting","p":["JSON is the new serialization format for trajectories. Currently, trajectory constraints are not included in serialization, and thus cannot be exported. To export a trajectory from the GUI, copy the outputted JSON, and paste it into SerializableTrajectory.fromJSON. From there you can call toTrajectory to get a result. An example might look like this:"]}]]